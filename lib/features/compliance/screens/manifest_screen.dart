import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:printing/printing.dart';
import 'package:share_plus/share_plus.dart';
import 'package:url_launcher/url_launcher.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart' show getTemporaryDirectory;
import '../../jobs/models/job_model.dart';
import '../services/manifest_service.dart';

class ManifestScreen extends ConsumerStatefulWidget {
  final Job job;
  final String hostName;
  final String haulerName;
  final String? hostCompany;
  final String? haulerCompany;

  const ManifestScreen({
    super.key,
    required this.job,
    required this.hostName,
    required this.haulerName,
    this.hostCompany,
    this.haulerCompany,
  });

  @override
  ConsumerState<ManifestScreen> createState() => _ManifestScreenState();
}

class _ManifestScreenState extends ConsumerState<ManifestScreen> {
  Uint8List? _pdfBytes;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _generatePdf();
  }

  Future<void> _generatePdf() async {
    final bytes = await ref.read(manifestServiceProvider).generateManifest(
      job: widget.job,
      hostName: widget.hostName,
      haulerName: widget.haulerName,
      hostCompany: widget.hostCompany,
      haulerCompany: widget.haulerCompany,
    );
    if (mounted) {
      setState(() {
        _pdfBytes = bytes;
        _isLoading = false;
      });
    }
  }

  Future<void> _printManifest() async {
    if (_pdfBytes == null) return;
    await Printing.layoutPdf(onLayout: (_) => _pdfBytes!);
  }

  Future<void> _shareManifest() async {
    if (_pdfBytes == null) return;

    // Save to temp file and share
    final dir = await getTemporaryDirectory();
    final file = File('${dir.path}/manifest_${widget.job.id.substring(0, 8)}.pdf');
    await file.writeAsBytes(_pdfBytes!);

    await Share.shareXFiles(
      [XFile(file.path)],
      text: 'FillExchange Manifest — Job ${widget.job.id.substring(0, 8)}',
    );
  }

  Future<void> _emailManifest() async {
    if (_pdfBytes == null) return;

    // Save to temp file first
    final dir = await getTemporaryDirectory();
    final file = File('${dir.path}/manifest_${widget.job.id.substring(0, 8)}.pdf');
    await file.writeAsBytes(_pdfBytes!);

    final subject = Uri.encodeComponent('FillExchange Manifest — Job ${widget.job.id.substring(0, 8)}');
    final body = Uri.encodeComponent(
      'Please find the attached manifest for Job ${widget.job.id.substring(0, 8)}.\n\n'
      'Material: ${widget.job.material ?? "N/A"}\n'
      'Quantity: ${widget.job.quantity?.toStringAsFixed(1) ?? "N/A"} units\n'
      'Pickup: ${widget.job.pickupAddress ?? "N/A"}\n'
      'Dropoff: ${widget.job.dropoffAddress ?? "N/A"}\n\n'
      'Generated by FillExchange',
    );

    final uri = Uri.parse('mailto:?subject=$subject&body=$body');
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri);
    }

    // Also trigger the share sheet so they can attach the PDF
    await Share.shareXFiles(
      [XFile(file.path)],
      text: 'FillExchange Manifest',
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Manifest #${widget.job.id.substring(0, 8).toUpperCase()}'),
        actions: [
          if (!_isLoading) ...[
            IconButton(
              icon: const Icon(Icons.print),
              tooltip: 'Print',
              onPressed: _printManifest,
            ),
            IconButton(
              icon: const Icon(Icons.share),
              tooltip: 'Share',
              onPressed: _shareManifest,
            ),
            IconButton(
              icon: const Icon(Icons.email),
              tooltip: 'Email',
              onPressed: _emailManifest,
            ),
          ],
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _pdfBytes == null
              ? const Center(child: Text('Failed to generate manifest'))
              : PdfPreview(
                  build: (_) => _pdfBytes!,
                  canChangeOrientation: false,
                  canChangePageFormat: false,
                  canDebug: false,
                ),
    );
  }
}
