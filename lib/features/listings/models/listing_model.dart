import '../../../core/models/geo_point.dart';
import 'dart:typed_data';

enum ListingType { offering, needing }
enum FillMaterial { cleanFill, topsoil, gravel, clay, mixed, other }
enum VolumeUnit { cubicYards, tons }
enum ListingStatus { active, sold, archived, pending }

class Listing {
  final String id;
  final String hostUid;
  final ListingType type;
  final FillMaterial material;
  final double quantity;
  final VolumeUnit unit;
  final double price; // 0 for free
  final String currency; // 'USD' default
  final String description;
  final List<String> photos;
  final GeoPoint? location; // Firestore GeoPoint
  final String? address;
  final ListingStatus status;
  final DateTime createdAt;

  const Listing({
    required this.id,
    required this.hostUid,
    required this.type,
    required this.material,
    required this.quantity,
    required this.unit,
    this.price = 0.0,
    this.currency = 'USD',
    this.description = '',
    this.photos = const [],
    this.location,
    this.address,
    this.status = ListingStatus.active,
    required this.createdAt,
  });

  factory Listing.fromMap(Map<String, dynamic> data, String id) {
    // Handle location: generic map or check for lat/long keys if we flatten it
    // For now assuming it's stored as jsonb or we extract it
    // Start with basic map check
    GeoPoint? loc;
    
    // Check various sources for location data (View exposes location_geojson)
    final rawLoc = data['location_geojson'] ?? data['location'];

    if (rawLoc != null) {
      // Check if it's GeoJSON map (Standard Supabase Select or View)
      if (rawLoc is Map) {
         if (rawLoc['type'] == 'Point' && rawLoc['coordinates'] is List) {
             final coords = rawLoc['coordinates'] as List;
             if (coords.length >= 2) {
                 // GeoJSON is [lng, lat]
                 loc = GeoPoint(coords[1].toDouble(), coords[0].toDouble());
             }
         }
         // Fallback for flat map
         else if (rawLoc['latitude'] != null && rawLoc['longitude'] != null) {
             loc = GeoPoint(rawLoc['latitude'], rawLoc['longitude']);
         }
      } 
      // Handle String (WKT or EWKB)
      else if (rawLoc is String) {
         String cleanLoc = rawLoc.trim().toUpperCase();
         
         // 1. EWKB HEX string (e.g., 0101000020E610...) generated by PostGIS in stream() queries
         if (cleanLoc.startsWith('01010000')) {
            try {
              bool hasSrid = cleanLoc.startsWith('0101000020');
              int dataStartIndex = 2 + 8 + (hasSrid ? 8 : 0);
              
              if (cleanLoc.length >= dataStartIndex + 32) {
                String lngHex = cleanLoc.substring(dataStartIndex, dataStartIndex + 16);
                String latHex = cleanLoc.substring(dataStartIndex + 16, dataStartIndex + 32);
                
                double parseLEHexDouble(String h) {
                  final bytes = Uint8List(8);
                  for (int i = 0; i < 8; i++) {
                    bytes[i] = int.parse(h.substring(i * 2, i * 2 + 2), radix: 16);
                  }
                  return ByteData.view(bytes.buffer).getFloat64(0, Endian.little);
                }
                
                double lng = parseLEHexDouble(lngHex);
                double lat = parseLEHexDouble(latHex);
                loc = GeoPoint(lat, lng);
              }
            } catch (_) {}
         }
         
         // 2. WKT format
         else {
             if (cleanLoc.startsWith('SRID=')) {
                final split = cleanLoc.split(';');
                if (split.length > 1) {
                  cleanLoc = split[1].trim();
                }
             }

             if (cleanLoc.startsWith('POINT')) {
               try {
                 final content = cleanLoc
                     .replaceAll('POINT', '')
                     .replaceAll('(', '')
                     .replaceAll(')', '')
                     .trim();
                 
                 final parts = content.split(RegExp(r'\s+')).where((s) => s.isNotEmpty).toList();
                 
                 if (parts.length >= 2) {
                   final lng = double.parse(parts[0]);
                   final lat = double.parse(parts[1]);
                   loc = GeoPoint(lat, lng);
                 }
               } catch (_) {}
             }
         }
      }
    }

    return Listing(
// ... (rest of constructor same as before until createdAt)
      id: id,
      hostUid: (data['owner_id'] ?? data['hostUid']) as String, // Support both for safety, prefer owner_id
      type: ListingType.values.firstWhere(
        (e) => e.name == (data['type'] as String? ?? 'offering'),
        orElse: () => ListingType.offering,
      ),
      material: FillMaterial.values.firstWhere(
        (e) => e.name == (data['material'] as String? ?? 'other'), // material is text
        orElse: () => FillMaterial.other,
      ),
      quantity: (data['quantity'] as num?)?.toDouble() ?? 0.0,
      unit: VolumeUnit.values.firstWhere(
        (e) => e.name == (data['unit'] as String? ?? 'cubicYards'),
        orElse: () => VolumeUnit.cubicYards,
      ),
      price: (data['price'] as num?)?.toDouble() ?? 0.0,
      currency: data['currency'] as String? ?? 'USD',
      description: data['description'] as String? ?? '',
      photos: (data['photos'] as List<dynamic>?)?.map((e) => e.toString()).toList() ?? [],
      location: loc,
      address: data['address'] as String?,
      status: ListingStatus.values.firstWhere(
        (e) => e.name == (data['status'] as String? ?? 'active'),
        orElse: () => ListingStatus.active,
      ),
      createdAt: (data['created_at'] is String)
          ? DateTime.parse(data['created_at'] as String)
          : (data['createdAt'] is String) // Fallback
              ? DateTime.parse(data['createdAt'] as String)
              : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'owner_id': hostUid, // Mapped to owner_id
      'type': type.name,
      'material': material.name,
      'quantity': quantity,
      'unit': unit.name,
      'price': price,
      'currency': currency,
      'description': description,
      'photos': photos,
      // Store location as WKT String (POINT(lng lat)) for better compatibility with PostREST insert
      'location': location != null 
          ? 'POINT(${location!.longitude} ${location!.latitude})'
          : null,
      'address': address,
      'status': status.name,
      'created_at': createdAt.toIso8601String(), // Mapped to created_at
    };
  }
}

// Simple GeoPoint replacement class if we remove cloud_firestore dependency entirely
// But wait, Listing model imported cloud_firestore. We need to remove that import too.
// I will create a local GeoPoint class or use latlong2 LatLng.
// Let's check imports in the next step. I'll define a simple class here or use LatLng.
// StartLine 41 of original file.
